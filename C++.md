#### 数组

##### 一维数组

```
数组名的作用：
1.可以统计整个数组的在内存的长度   sizeof(arr);
2.可以获取数组在内存的首地址 
```

```cpp
/**声明数组*/
//type arrayName [ arraySize ];
int a[100];

/*初始化*/
//指定数组长度
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
double balance[5] = {1000.0};//没有全部初始，后面默认为0
//不指定长度
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};

/**访问*/
//用下标(从0开始)访问
cout<<balance[0]<<endl;

```

##### 二维数组

```
数组名的作用：
1.可以统计整个数组的在内存的长度   sizeof(arr);
2.可以获取二维数组在内存的首地址 
```



```cpp
/**
多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：
type arrayName [ x ][ y ];
*/


/**
初始化二维数组
*/
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};

//内部嵌套的括号是可选的，下面的初始化与上面是等同的：
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};


/**
访问二维数组元素
*/
//二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：
int val = a[2][3];

```

##### 动态数组--vertor



###### 向量容器vector

1. 动态数组，运行阶段设置长度
2. 具有数组的快速索引
3. 可以插入和删除

###### 定义和初始化

```cpp
vector <double > vec1;
vector <string > vec2(5);//假定数据宽度为5
vector <int > vec3(20,998)//默认20个元素每个都是998

```

###### 常用操作

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f37b81bb77f34479abd98be8f17ce7ef~tplv-k3u1fbpfcp-zoom-1.image)


###### 初见迭代器iterator

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ba330ecd2d475683ab2189c52bfd0f~tplv-k3u1fbpfcp-zoom-1.image)



------



#### 函数

```cpp
函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。

C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。

函数还有很多叫法，比如方法、子例程或程序，等等。
```

##### 函数定义

```cpp
return_type function_name( parameter list )
{
   body of the function
}
```

- 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：
  - **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
  - **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
  - **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
  - **函数主体：**函数主体包含一组定义函数执行任务的语句。

##### 函数声明

```cpp
return_type function_name( parameter list );
//在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：
```

##### 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有三种向函数传递参数的方式：

| 调用类型                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |

默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。

###### 参数的默认值

```cpp
/**当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。

这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：*/

#include <iostream>
using namespace std;
 
int sum(int a, int b=20)
{
  int result;
 
  result = a + b;
  
  return (result);
}
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
   int result;
 
   // 调用函数来添加值
   result = sum(a, b);
   cout << "Total value is :" << result << endl;
 
   // 再次调用函数
   result = sum(a);
   cout << "Total value is :" << result << endl;
 
   return 0;
}
```

##### Lambda表达式

```cpp
C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。

Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:

[capture](parameters)->return-type{body}
例如：
[](int x, int y){ return x < y ; }

如果没有返回值可以表示为：
[capture](parameters){body}
例如：
[]{ ++global_x; } 

在一个更为复杂的例子中，返回类型可以被明确的指定如下：
[](int x, int y) -> int { int z = x + y; return z + x; }
本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。

如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。

在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：

[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

[this]() { this->someFunc(); }();

```

实例

```cpp
#include <algorithm>
#include <cmath>
void abssort(float* x, unsigned N) {
    std::sort(x, x + N,
        // Lambda expression begins
        [](float a, float b) {
            return std::abs(a) < std::abs(b);
        });
}
```

### 第一天学习小结

也是因为acm的原因，在大一寒假的时候学了一下c++，但也只是简单的基础的用法，没有很系统的学习，当时主要是为了提高写代码的速度和方便，因为c++有stl。但是c++终究也是一门面向对象的语言，可以说之前对c++的认识其实还是基于c的拓展上，基本上都还没算入门，在学了java之后突然对c++这个面向对象也有了兴趣，因为一直用的c++打acm，虽然用不上面向对象，但是对其也是有一定执念的。所以打算趁着这段空闲的时间，搞他一波。由于c++是c的拓展，一些基础的语句语法很相似，我也就没说的很详细了，就简单快速的过了一遍，也有几个点还不错，如vector和lambda表达式。第一天就先到这里吧，明天就是指针和文件差不多，再后面就可以开始new一个对象了，hhhh....