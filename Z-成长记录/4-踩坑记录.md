- vue3不再提供全局API，提供的是createApp，而Vue2在ui注册的时候用的是vue.use(xxx)，这样就可能造成一定的渲染阻塞。
  - 解决方案：
    - 降低版本，什么写法就用什么版本。
    - cli4默认初始vue3项目模板，选择vue2。
    - 也可以改动模板代码，改成Vue2的初始化，但不推荐
  - 思考：为什么会发生这样的问题
    - 自己在用npm装东西时，过于’享受‘直装最新版本方式，不注意版本是否匹配或者合适，这可能短时间不会引发什么问题，但依旧存在未知的隐患，如果存在一些版本的依赖就会出问题，自己还很可能一直找不到问题的原因，效率很低。
- 需求就是组件切换后，需要立马拿到dom的数据，然后进行数据处理，渲染页面。问题是不能保证每次拿到的数据是当前组件实例的，可能是切换前的组件实例，我试过很多方法，$nexttick，拿全局路由钩子，监听路由。由于钩子里面是一个异步的过程，没办法保证执行时页面已经渲染完成，就不能保证拿到是数据是对的
  - 解决方案：利用事件循环的机制，把获取的步骤后移。
  - 思考：思维也不够发散，只想着找合适的钩子来解决，没有去思考如何利用他异步的这个原理去解决问题。
- 一些配置文件和接口文件改动后，如果发现不生效。一定要试试重启试试
- elementUI的el-select不能触发blur的检验。
  - 通过@blur事件，自己主动去触发。但是，blur触发时，如果有发生值改变，拿到了还是改变前的值，因为blur事件触发是在点击选项的那一刻，而在之后才发生了绑定值，这样就导致了空值验证。选择用blur和change事件混用，所以，其实每次失焦时都做了两次校验。
- Vue的整个生命周期，是一个代码块中的一部分，所以不是说created中使用任务完成之后才会执行mounted，异步任务依旧符合事件循环机制。
