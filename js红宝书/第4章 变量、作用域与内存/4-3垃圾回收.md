#### 为什么会有垃圾回收？

我们会分配出去很多内存，当这些内存不在被用到时，却不能被释放，就会造成内存泄漏。如果这样的情况越来越多，会导致内存不够用而系统崩溃。

-------

#### 垃圾回收

​	JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。 JavaScript 为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。这里就不得不提到两种主要的标记策略：**标记清理和引用计数**

---

#### 标记清理

JavaScript 最常用的垃圾回收策略是标记清理（ mark-and-sweep）。

**实现原理：通过判断一个变量是否在执行环境中被引用，来进行标记删除。**

 **具体步骤：**

- 垃圾回收器给所有内存变量进行标记
- 然后去掉执行环境中和被引用的标记，
- 剩余的标记变量是不会被用到的变量，被垃圾回收器回收。

-----

#### 引用计数

**实现原理：跟踪记录每个值被引用的次数，判断当前被引用次数来清理**

**具体步骤：**

- 当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加 1。
- 当同一值又被赋予另一个变量，该值的引用计数继续加 1 。
- 当引用该值的变量被另一个值所取代，则该值的引用计数减 1，另外一个值的引用计数加1
- 当计数为0的时候，说明无法在访问这个值了，所有系统将会收回该值所占用的内存空间。

##### **存在的缺陷**

**两个对象的相互循环引用** 

> 在函数执行完成的时候，两个对象相互的引用计数并未归 0 ，而是依然占据内存，无法回收，当该函数执行多次时，内存占用就会变多，导致大量的内存得不到回收。

-----

#### 内存管理

在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。但也存在一个问题就是 **分配给** **Web** **浏览器的可用内存数量通常比分配给桌面应用程序的少** 。
 为了能够让页面获得最好的性能，必须确保 js 变量占用最少的内存，最好的方式就是将不用的变量引用释放掉，也叫做**解除引用**。

- **局部变量:**函数执行完成离开环境变量，变量将自动解除。
- **全局变量:**对于全局变量我们需要进行手动解除。(注意:解除引用并不意味被收回，而是将变量 真正的脱离执行环境，下一次垃圾回收将其收回)

```js
var a = 20; // 在栈内存中给数值变量分配空间 
alert(a + 100); // 使用内存
var a = null; // 使用完毕之后，释放内存空间
```

**注意：**由标记清除法的原理得知，只有与环境变量失去引用的变量才会被标记回收，所用上述例子通过将对象的引用设置为 null ，此变量也就失去了引 用，等待被垃圾回收器回收。

##### 1. 通过 const 和 let 声明提升性能

​		ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 const和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生

##### 2.内存泄露

**意外声明全局变量是最常见但也最容易修复的内存泄漏问题**。

```
function setName() {
		name = 'Jake';
}
```

分析：此时，解释器会把变量 name 当作 window 的属性来创建（相当于 window.name = 'Jake'）。可想而知，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上 var、 let 或 const 关键字即可，这样变量就会在函数执行完毕后离开作用域。

**定时器也可能会悄悄地导致内存泄漏**。下例中，定时器的回调通过闭包引用了外部变量。

```js
let name = 'Jake';
setInterval(() => {
	console.log(name);
}, 100);
```

分析：定时器一直运行，回调函数中引用的 name 就会一直占用内存，垃圾回收器就不会清理它。

**使用闭包很容易在不知不觉间造成内存泄漏。**

```js
let outer = function() {
	let name = 'Jake';
	return function() {
		return name;
	};
};
```

分析：调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。