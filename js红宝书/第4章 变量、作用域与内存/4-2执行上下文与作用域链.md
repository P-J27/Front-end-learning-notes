#### 执行上下文

​    执行上下文的概念在 JavaScript 中是颇为重要的，我理解是一种执行环境的一种对象化的体现，不能理解上下文是什么的时候，就当做对象来理解。变量或函数的上下文决定了它们**可以访问哪些数据，以及它们的行为**。它保存着函数执行所需的重要信息，有着三个重要属性：

- **变量对象(variable object)**
- **作用域链(scope chain)**
- **this指针(this value)**

#### 全局上下文

​    在浏览器中，**全局上下文就是我们常说的 window 对象**，因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。（注意：使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的）

#### 变量对象

​    每个上下文都有一个关联的变量对象（ variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。而每当一个**函数执行**之前，执行引擎都会为这个函数创建他的上下文对象，创建上下文对象的时候，就会创建它的重要属性 => **变量对象**。创建变量对象的过程如下。

- 创建arguments对象。(全局上下文的变量对象没有arguments对象)
- 变量提升
  - 找到函数内所有函数声明，存储在变量对象中，key是函数名，value是函数的引用。
  - 找到函数内所有变量声明，存储在变量对象中，key是变量名，value是undefined。

​    上下文的生命周期在其所有代码执行完后结束，上下文对象被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

#### 上下文栈

​     JS在执行的时候会维护一个上下文栈，每次开始执行一个函数之前，JS都要创建一个上下文对象，并将其压入上下文栈中。因此，当前正在执行的函数的上下文（简称当前上下文）总是在栈顶，这个函数一执行完，其上下文就会从栈中弹出，被销毁。将控制权返还给之前的执行上下文。这个执行栈就映射出执行的顺序。代码开始运行时，栈顶会先放入一个全局上下文（全局上下文同样有变量对象，作用域链和this指针）

#### 作用域链

​	上下文中的代码在执行的时候，会创建变量对象的一个作用域链（ scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序和范围。代码正在执行的上下文的变量对象始终位于作用域链的最前端。代码执行时的标识符(变量)解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从**作用域链的最前端开始，然后逐级往后**，直到找到标识符。（这就是外层不能访问内层，内层可以访问外层的原因）

**实例**

```js
var color = "blue";
function changeColor() {
	if (color === "blue") {
			color = "red";
	} else {
					color = "blue";
	}
}
changeColor();
```

分析：函数 changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义 arguments 对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在**作用域链**中找到它。

#### 变量声明

##### var 的函数作用域声明	

在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函
数的局部上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：

```js
function add(num1, num2) {
   var sum = num1 + num2;
   return sum;
}
let result = add(10, 20); // 30
console.log(sum); // 报错： sum 在这里不是有效变量
```

var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“**提升**”
（ hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。声明的提升意味着会输出 undefined 而不是Reference Error。

##### let 的块级作用域声明

​	ES6 新增的 let 关键字跟 var 很相似，但它的**作用域是块级**的，这也是 JavaScript 中的新概念。块级作用域由最近的一对包含花括号{}界定。换句话说， if 块、 while 块、 function 块，甚至连单独的块也是 let 声明变量的作用域。

​	let 与 var 的另一个不同之处是在同一作用域内不能重复声明。重复的 var 声明会被忽略，而重
复的 let 声明会抛出 SyntaxError。

​	let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代**变量会泄漏到循环外部**，这种情
况应该避免。来看下面两个例子：

```js
for (var i = 0; i < 10; ++i) {}
console.log(i); // 10
for (let j = 0; j < 10; ++j) {}
console.log(j); // ReferenceError: j 没有定义
```

​	严格来讲， let 在 JavaScript 运行时中也会被提升，但由于“**暂时性死区**”（ temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说， let 的提升跟 var是不一样的。

关于暂时性死区，官方的解释。

> 当程序的控制流程在新的作用域（module function 或 block作用域）进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。

只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

**存在死区**

```js
var tmp = 123;
if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```
**不存在死区**
```js
var tmp = 123;
if (true) {
  tmp = 'abc'; // ReferenceError
  //let tmp;
}
```

分析：这样的解释，var和let、const的声明都会被提升，声明都大家都还没有被绑定值，var声明的就是undefined，而let，const声明的就直接不让访问，只有进行了词法绑定后（即只能在声明代码的后面可以使用该变量，在声明代码那一行上面就是一个死区，不能访问该变量）才可以访问，这就是暂时性死区。

##### const 的常量声明

​	除了 let， ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。
一经声明，在其生命周期的任何时候都不能再重新赋予新值。除了以上规则外，其他方面和let基本上都相同。

​	const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值
为其他引用值，但对象的键则不受限制。下例。

```js
const o1 = {};
o1 = {}; // TypeError: 给常量赋值
const o2 = {};
o2.name = 'Jake';
console.log(o2.name); // 'Jake'
```

​	如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，
但会静默失败

```js
const o3 = Object.freeze({});
o3.name = 'Jake';
console.log(o3.name); // undefined
```

​	由于 const 声明暗示变量的值是单一类型且不可修改， JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化
