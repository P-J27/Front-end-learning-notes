 HTTP的报文，也是`header + body`的结构，具体:

```
起始行 + 头部 + 空行 + 实体
```

由于 http `请求报文`和`响应报文`是有一定区别，因此我们分开介绍。

### 起始行/通用首部

对于**请求报文**来说，起始行类似下面这样:

```
GET /home HTTP/1.1
请求方法/请求路径url/http协议版本号
```

也就是**方法 + 路径 + http版本**。

对于**响应报文**来说，起始行一般张这个样:

```
HTTP/1.1 200 OK
//http协议版本号、状态码、状态描述
```

响应报文的起始行也叫做`状态行`。由**http协议版本号、状态码和状态描述**三部分组成。

值得注意的是，在起始行中，每两个部分之间用**空格**隔开，最后一个部分后面应该接一个**换行**，严格遵循`ABNF`语法规范。

### 头部

展示一下**请求头和响应头**在报文中的位置:

![image-20211018141626293](https://gitee.com/p_pj/pig/raw/master/img/image-20211018141626293.png)

![img](https://gitee.com/p_pj/pig/raw/master/img/170ffd62af8538e4~tplv-t2oaga2asx-watermark.awebp)

不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到`http`非常多的特性，首先看看这些头部字段的格式：

- 字段名不区分大小写
- 字段名不允许出现空格，不可以出现下划线`_`
- 字段名后面必须**紧接着`:`**

#### 请求头

> **Accept**: 接收类型，表示浏览器支持的MIME类型
> （对标服务端返回的Content-Type）
> Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
> Content-Type：客户端发送出去实体内容的类型
> **Cache-Control**: 指定请求和响应遵循的缓存机制，如no-cache
> If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
> **Expires**：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
> **Max-age**：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
> If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
> **Cookie**: 有cookie并且同域访问时会自动带上
> **Connection**: 当浏览器与服务器通信时对于**长连接**如何进行处理,如**keep-alive**
> Host：请求的服务器URL
> Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
> Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
> User-Agent：用户客户端的一些必要信息，如UA头部等

#### 响应头

> Access-Control-Allow-Headers: 服务器端允许的请求Headers
> Access-Control-Allow-Methods: 服务器端允许的请求方法
> Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
> Content-Type：服务端返回的实体内容的类型
> Date：数据从服务器发送的时间
> Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
> Last-Modified：请求资源的最后修改时间
> Expires：应该在什么时候认为文档已经过期,从而不再缓存它
> Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
> ETag：请求变量的实体标签的当前值
> Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
> Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
> Server：服务器的一些相关信息

`一般来说，请求头部和响应头部是匹配分析的。`

- 譬如，请求头部的Accept要和响应头部的Content-Type匹配，否则会报错
- 譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误
- 譬如，在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应

### 空行

很重要，用来区分开`头部`和`实体`。

问: 如果说在头部中间故意加一个空行会怎么样？

那么空行后的内容全部被视为实体。

### 实体

就是具体的数据了，也就是`body`部分。请求报文对应`请求体`, 响应报文对应`响应体`。

- http请求时，除了头部，还有消息实体，一般来说,请求实体中会将需要的参数都放入（用于post请求）。

- 譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件）等等
- 而一般响应实体中，就是放服务端需要传给客户端的内容
- 一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。

### HTTP 特点

HTTP 的特点概括如下:

1. 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
2. **可靠传输。 ** **HTTP 基于 TCP/IP**，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
3. 请求-应答。也就是`一发一收`、`有来有回`， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演**请求方**的角色。
4. 无状态。这里的状态是指**通信过程的上下文信息**，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

### HTTP 缺点

#### 无状态

所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的**无状态**。

在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。

但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

#### 明文传输

即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。

这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。`WIFI陷阱`就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

#### 队头阻塞问题

当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的**队头阻塞**问题。在http2.0版本做了解决。


