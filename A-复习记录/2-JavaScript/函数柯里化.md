#### 什么是柯里化

> 柯里化，是函数式编程的一个重要概念。它既`能减少代码冗余，也能增加可读性`。另外，附带着还能用来装逼。
>
> 先给出柯里化的定义：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

柯里化的定义，理解起来有点费劲。为了更好地理解，先看下面这个例子：

```js
function sum (a, b, c) {
    console.log(a + b + c);
}
sum(1, 2, 3); // 6
```

毫无疑问，sum 是个简单的累加函数，接受3个参数，输出累加的结果。

假设有这样的需求，sum的前2个参数保持不变，最后一个参数可以随意。那么就会想到，在函数内，是否可以把前2个参数的相加过程，给抽离出来，因为参数都是相同的，没必要每次都做运算。

如果先不管函数内的具体实现，调用的写法可以是这样： `sum(1, 2)(3);` 或这样 `sum(1, 2)(10);` 。就是，先把前2个参数的运算结果拿到后，再与第3个参数相加。

这其实就是函数柯里化的简单应用。



#### 柯里化的实现

`sum(1, 2)(3);` 这样的写法，并不常见。拆开来看，`sum(1, 2)` 返回的应该还是个函数，因为后面还有 `(3)` 需要执行。

那么反过来，从最后一个参数，从右往左看，它的左侧必然是一个函数。以此类推，如果前面有n个()，那就是有n个函数返回了结果，只是返回的结果，还是一个函数。是不是有点递归的意思？

网上有一些不同的柯里化的实现方式，以下是个人觉得最容易理解的写法：

```js
function curry (fn, currArgs) {
    return function() {
        let args = [].slice.call(arguments);

        // 首次调用时，若未提供最后一个参数currArgs，则不用进行args的拼接
        if (currArgs !== undefined) {
            args = args.concat(currArgs);
        }

        // 递归调用
        if (args.length < fn.length) {
            return curry(fn, args);
        }

        // 递归出口
        return fn.apply(null, args);
    }
}
```

解析一下 curry 函数的写法：

首先，它有 2 个参数，fn 指的就是本文一开始的源处理函数 `sum`。currArgs 是调用 curry 时传入的参数列表，比如 `(1, 2)(3)` 这样的。

再看到 curry 函数内部，它会整个返回一个匿名函数。

再接下来的 `let args = [].slice.call(arguments);`，意思是将 arguments 数组化。arguments 是一个类数组的结构，它并不是一个真的数组，所以没法使用数组的方法。我们用了 call 的方法，就能愉快地对 args 使用数组的原生方法了。

`currArgs !== undefined` 的判断，是为了解决递归调用时的参数拼接。

最后，判断 args 的个数，是否与 fn (也就是 sum )的参数个数相等，相等了就可以把参数都传给 fn，进行输出；否则，继续递归调用，直到两者相等。

测试一下：

```js
function sum(a, b, c) {
    console.log(a + b + c);
}

const fn = curry(sum);

fn(1, 2, 3); // 6
fn(1, 2)(3); // 6
fn(1)(2, 3); // 6
fn(1)(2)(3); // 6
```

都能输出 6 了，搞定！

#### 总结

**函数的柯里化，是 Javascript 中函数式编程的一个重要概念。它返回的，是一个函数的函数。其实现方式，需要依赖参数以及递归，通过拆分参数的方式，来调用一个多参数的函数方法，以达到减少代码冗余，增加可读性的目的。**

虽然一开始理解起来有点云里雾里的，但一旦理解了其中的含义和具体的使用场景，用起来就会得心应手了。