Vue 组件间通信只要指以下 3 类通信：`父子组件通信、隔代组件通信、兄弟组件通信`

---------------

#### 1、**`props / $emit`**

解析：`适用 父子组件通信`,这是最基础的，就不细说了。

#### 2、**`ref` 与 `$parent / $children`**

解析：适用 父子组件通信

- `ref`和`refs`
  - 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；
  - 如果用在子组件上，引用就指向组件实例
- `$parent` / `$children`：访问父 / 子实例

#### 3、**`EventBus （$emit / $on）`**

解析：这种方法通过一个空的 Vue 实例作为中央`事件总线`（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括`父子、隔代、兄弟组件。`

```js
var Event=new Vue();
Event.$emit(事件名,数据); //通信主动方发送事件
Event.$on(事件名,data => {}); //通信接收方处理事件
```

#### 4、**`$attrs`/`$listeners`**

解析：适用于 隔代组件通信，如果仅仅是传递数据，而不做中间处理时非常适合

- `$attrs`：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 inheritAttrs 选项一起使用。
- `$listeners`：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件

#### 5、**`provide / inject`**

解析：适用于 隔代组件通信

祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。

 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

**注意：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的,可以像理解浅拷贝一样理解**

#### 6、**`Vuex`**

解析：适用于 父子、隔代、兄弟组件通信。原理上和事件总线上有些相似。

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

- Vuex 的`状态存储是响应式`的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到`高效更新。`
- 改变 store 中的状态的唯一途径就是`显式地提交  (commit) mutation`。这样使得我们可以方便地`跟踪每一个状态的变化`。

#### 小结

按照使用场景可以分为三类：

- 父子通信：	
  - 父向子传递数据是通过 props，子向父是通过 events（`$emit`）
  - 通过父链 / 子链也可以通信（`$parent` / `$children`）；
  - ref 也可以访问组件实例；
  - provide / inject API；
  - `$attrs/$listeners`

- 兄弟通信：
  - EventBus；
  - Vuex

- 跨级通信：
  - EventBus；
  - Vuex；
  - provide / inject API、
  - `$attrs/$listeners`